{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "dprint configuration",
  "type": "object",
  "definitions": {
    "indentWidth": {
      "type": "number",
      "description": "The number of spaces for an indent. This option is ignored when using tabs.",
      "default": 4
    },
    "lineWidth": {
      "type": "number",
      "description": "The width of a line the printer will try to stay under. Note that the printer may exceed this width in certain cases.",
      "default": 120
    },
    "useTabs": {
      "type": "boolean",
      "description": "Whether to use tabs (true) or spaces (false).",
      "default": false
    },
    "bracePosition": {
      "type": "string",
      "description": "Where to place the brace.",
      "oneOf": [
        { "const": "maintain", "description": "Maintains the brace being on the next line or the same line." },
        { "const": "sameLine", "description": "Forces the brace to be on the same line." },
        { "const": "nextLine", "description": "Forces the brace to be on the next line." },
        { "const": "nextLineIfHanging", "description": "Forces the brace to be on the next line if the same line is hanging, but otherwise uses the next." }
      ],
      "default": "nextLineIfHanging"
    },
    "nextControlFlowPosition": {
      "type": "string",
      "description": "Where to place the next control flow within a control flow statement.",
      "oneOf": [
        { "const": "maintain", "description": "Maintains the next control flow being on the next line or the same line." },
        { "const": "sameLine", "description": "Forces the next control flow to be on the same line." },
        { "const": "nextLine", "description": "Forces the next control flow to be on the next line." }
      ],
      "default": "nextLine"
    },
    "trailingCommas": {
      "type": "string",
      "description": "If trailing commas should be used.",
      "oneOf": [
        { "const": "never", "description": "Trailing commas should not be used." },
        { "const": "always", "description": "Trailing commas should always be used." },
        { "const": "onlyMultiLine", "description": "Trailing commas should only be used in multi-line scenarios." }
      ],
      "default": "never"
    },
    "useBraces": {
      "type": "string",
      "description": "If braces should be used or not.",
      "oneOf": [
        { "const": "maintain", "description": "Uses braces if they're used. Doesn't use braces if they're not used." },
        { "const": "always", "description": "Forces the use of braces. Will add them if they aren't used." },
        { "const": "preferNone", "description": "Forces no braces when when the header is one line and body is one line. Otherwise forces braces." }
      ],
      "default": "maintain"
    }
  },
  "required": ["projectType"],
  "properties": {
    "projectType": {
      "type": "string",
      "description": "Specify the type of project this is. You may specify any of the possible values here according to your conscience.",
      "oneOf": [
        {
          "const": "openSource",
          "description": "Dprint is formatting an open source project."
        },
        {
          "const": "commercialSponsored",
          "description": "Dprint is formatting a closed source commercial project and your company sponsored dprint."
        },
        {
          "const": "commercialDidNotSponsor",
          "description": "Dprint is formatting a closed source commercial project and you want to forever enshrine your name in source control for having specified this."
        }
      ]
    },
    "lineWidth": {
      "$ref": "#/definitions/lineWidth"
    },
    "indentWidth": {
      "$ref": "#/definitions/indentWidth"
    },
    "useTabs": {
      "$ref": "#/definitions/useTabs"
    },
    "semiColons": {
      "type": "boolean",
      "description": "Whether statements should use semi-colons.",
      "default": true
    },
    "singleQuotes": {
      "type": "boolean",
      "description": "Whether to use single quotes (true) or double quotes (false).",
      "default": false
    },
    "newlineKind": {
      "type": "string",
      "description": "The kind of newline to use.",
      "oneOf": [
        { "const": "auto", "description": "For each file, uses the newline kind found at the end of the last line." },
        { "const": "crlf", "description": "Uses carriage return, line feed." },
        { "const": "lf", "description": "Uses line feed." },
        { "const": "system", "description": "Uses the system standard (ex. crlf on Windows)." }
      ],
      "default": "auto"
    },
    "useBraces": {
      "$ref": "#/definitions/useBraces"
    },
    "bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "nextControlFlowPosition": {
      "$ref": "#/definitions/nextControlFlowPosition"
    },
    "trailingCommas": {
      "$ref": "#/definitions/trailingCommas"
    },

    "typescript.lineWidth": {
      "$ref": "#/definitions/lineWidth"
    },
    "json.lineWidth": {
      "$ref": "#/definitions/lineWidth"
    },

    "typescript.indentWidth": {
      "$ref": "#/definitions/indentWidth"
    },
    "json.indentWidth": {
      "$ref": "#/definitions/indentWidth"
    },

    "typescript.useTabs": {
      "$ref": "#/definitions/useTabs"
    },
    "json.useTabs": {
      "$ref": "#/definitions/useTabs"
    },

    "enumDeclaration.memberSpacing": {
      "type": "string",
      "description": "How to space the members of an enum.",
      "oneOf": [
        { "const": "newline", "description": "Forces a new line between members." },
        { "const": "blankline", "description": "Forces a blank line between members." },
        { "const": "maintain", "description": "Maintains whether a newline or blankline is used." }
      ],
      "default": "newline"
    },

    "breakStatement.semiColon": {
      "type": "boolean"
    },
    "callSignature.semiColon": {
      "type": "boolean"
    },
    "classMethod.semiColon": {
      "type": "boolean"
    },
    "classProperty.semiColon": {
      "type": "boolean"
    },
    "constructSignature.semiColon": {
      "type": "boolean"
    },
    "continueStatement.semiColon": {
      "type": "boolean"
    },
    "debuggerStatement.semiColon": {
      "type": "boolean"
    },
    "directive.semiColon": {
      "type": "boolean"
    },
    "doWhileStatement.semiColon": {
      "type": "boolean"
    },
    "exportAssignment.semiColon": {
      "type": "boolean"
    },
    "expressionStatement.semiColon": {
      "type": "boolean"
    },
    "functionDeclaration.semiColon": {
      "type": "boolean"
    },
    "ifStatement.semiColon": {
      "type": "boolean"
    },
    "importDeclaration.semiColon": {
      "type": "boolean"
    },
    "importEqualsDeclaration.semiColon": {
      "type": "boolean"
    },
    "indexSignature.semiColon": {
      "type": "boolean"
    },
    "mappedType.semiColon": {
      "type": "boolean"
    },
    "methodSignature.semiColon": {
      "type": "boolean"
    },
    "moduleDeclaration.semiColon": {
      "type": "boolean"
    },
    "namespaceExportDeclaration.semiColon": {
      "type": "boolean"
    },
    "propertySignature.semiColon": {
      "type": "boolean"
    },
    "returnStatement.semiColon": {
      "type": "boolean"
    },
    "throwStatement.semiColon": {
      "type": "boolean"
    },
    "typeAlias.semiColon": {
      "type": "boolean"
    },
    "variableStatement.semiColon": {
      "type": "boolean"
    },

    "forInStatement.useBraces": {
      "$ref": "#/definitions/useBraces"
    },
    "forOfStatement.useBraces": {
      "$ref": "#/definitions/useBraces"
    },
    "forStatement.useBraces": {
      "$ref": "#/definitions/useBraces"
    },
    "ifStatement.useBraces": {
      "$ref": "#/definitions/useBraces"
    },
    "whileStatement.useBraces": {
      "$ref": "#/definitions/useBraces"
    },

    "arrowFunctionExpression.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "classDeclaration.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "classExpression.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "classMethod.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "doWhileStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "enumDeclaration.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "forInStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "forOfStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "forStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "functionDeclaration.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "functionExpression.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "ifStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "interfaceDeclaration.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "moduleDeclaration.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "switchStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "tryStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },
    "whileStatement.bracePosition": {
      "$ref": "#/definitions/bracePosition"
    },

    "ifStatement.nextControlFlowPosition": {
      "$ref": "#/definitions/nextControlFlowPosition"
    },
    "tryStatement.nextControlFlowPosition": {
      "$ref": "#/definitions/nextControlFlowPosition"
    },

    "arrayExpression.trailingCommas": {
      "$ref": "#/definitions/trailingCommas"
    },
    "arrayPattern.trailingCommas": {
      "$ref": "#/definitions/trailingCommas"
    },
    "enumDeclaration.trailingCommas": {
      "$ref": "#/definitions/trailingCommas"
    },
    "objectExpression.trailingCommas": {
      "$ref": "#/definitions/trailingCommas"
    },
    "tupleType.trailingCommas": {
      "$ref": "#/definitions/trailingCommas"
    }
  }
}
