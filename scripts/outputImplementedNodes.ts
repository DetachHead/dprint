import { createProject } from "./createProject";
import { BabelAnalyzer, BabelNode } from "./babel";
import { BabelNodeProperty } from "./babel/BabelNodeProperty";

const project = createProject();
const babelAnalyzer = new BabelAnalyzer(project);
const fileSystem = project.getFileSystem();

const implementedNodes: BabelNode[] = [];
const unImplementedNodes: BabelNode[] = [];

for (const node of babelAnalyzer.getNodes()) {
    if (node.isReferenced())
        implementedNodes.push(node);
    else
        unImplementedNodes.push(node);
}

let output = `# Implemented Nodes\n\n`
output += `This file is automatically generated.\n\n`;

outputHeader("Implemented", implementedNodes);

for (const node of implementedNodes) {
    output += `* ${node.getName()}\n`;
    for (const prop of node.getProperties()) {
        if (isAllowedProperty(prop))
            outputProperty(prop);
    }
}

output += "\n";

outputHeader("Not implemented", unImplementedNodes);

for (const node of unImplementedNodes)
    output += `* ${node.getName()}\n`;

fileSystem.writeFileSync("implemented-nodes.md", output);

function outputHeader(header: string, nodes: BabelNode[], additionalText?: string) {
    output += `## ${header}\n\n`;
    if (additionalText != null)
        output += additionalText + "\n\n";
    output += `**Total:** ${nodes.length}\n\n`;
}

function outputProperty(prop: BabelNodeProperty) {
    output += `    * ${prop.isReferenced() ? ":heavy_check_mark:" : ":x:"} ${prop.getName()}\n`;
}

function isAllowedProperty(prop: BabelNodeProperty) {
    switch (prop.getName()) {
        case "type":
            return false;
    }

    return true;
}